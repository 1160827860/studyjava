#数据结构基础
# 分清楚什么是值传递和引用传递（理解可能有问题，在基本类型方面）
值传递就是int a = 10;代表10是保存在a的地址中的。此时b = a; a = 50; 输出
的话是a = 50，b = 10;这是一种值传递对于基本类型好像都是值传递String 
也是但是对于对象，他们是引用传递引用传递就是：
例如：Node a = new Node();
这样是指向内存中某个区域
b = a;
b中存储了a中的地址
a要是内容变化就b也会改变，因为指向同一片区域
但是如果只是将a = null只是将a存储内存地址置为null，b是不会改变的,因为
只是改变了a中的存储的地址位置。

# 赋值=、浅克隆、深克隆(不是很理解)
赋值也分为三类

= ：表示将地址赋值给当前引用

浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于**非基本
类型仍然指向原有属性所指向的内存地址**，**基本类型**是**不一样的内存地址**。
extends Cloneable
继承这个接口然后调用父类的方法

深克隆：创建一个新对象，新对象的基本类型的对象类型回事不一样的。
使用序列化和反序列化，让对象接口可序列化，然后写一个对象输入输出流
将对象先读入然后输出就成了新的对象。

#在迭代器或者循环中不能对链表结构进行修改不然会报错
但是迭代器自带了remove()方法。

# java中创建泛型数组
不可以直接像创建基本数组一样创建泛型数组,
- 使用反射越过
- 或者就是使用Object

# 链表一些常见问题
ArrayList 数组队列，相当于动态数组,随机访问效率高，随机插入、删除效率
低，因为删除和插入一个，后面元素都要往后面移动，**线程不安全**。
LinkedList 双向链表，它可以当作堆栈，队列和双端队列，随机访问效率低，
但随机插入删除效率高。
Vector 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。
**Vector是线程安全的**。
Stack是栈，继承Vector，先进后出。

剑指offic<br>
（1）链表反转：
- 1：将链表里面的值保存到数组，然后利用循环倒着再添加一次，返回链表
- 2：利用一个额外容器，将第i = 0，i++个和j = size - 1 ，size--;最后一个，
即直到size/2
- 3：利用递归，DFS每次进入到链表末尾，然后从末尾到链表头。
-4: 正统递归：
```java
    if (head == null || head.next == null){ return head;}
        ListNode p = q206(head.next);
        head.next.next = head;
        head.next = null;
        return p;
```
（2）链表查找循环：<br>
- 1：利用哈希表，如果添加的时候，出现重复的情况，自然是
- 2：知道size，反转链表节点，不能到达首节点则有循环。

（3）链表去重：<br>
- 1：利用哈希表，将链表中内容保存再哈希表中，再将哈希表中内容给链表
    赋值<br>
    **优化**：利用HashSet的add方法来判断是不是已经重复了，然后决定是
    不是要添加。
- 2：两次循环也可以，每过一个点扫描整个表检查是不是有重复。
- 3：使用递归
(4)回文链表：
- 我想到的办法：装入栈中，然后分一半装入另一个栈中，弹出之后检查
leetcode中的办法一：复制链表到数组列表中，使用双指针法判断是否是回文
时间复杂度O(n)空间复杂度O(n)
- 递归实现时间复杂度O(n) 空间复杂度O(1)
- 方法三：避免使用 O(n)O(n) 额外空间的方法就是改变输入。
 我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半
 部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能
 通过测试用例，因为使用该函数的人不希望链表结构被更改。




#== 和equal方法的区别(更深入的原因应该在JVM里面)
==是比较基本类型是否相同，例如int和布尔，这个也是比较在内存是位置
是否一样。
equal可以比较对象和String
```java
        String a  = "Helloasfsdgfjhugjhkjhlksawqwrewqrwqe2121让我撒发热我虽然32";
        String b = "Helloasfsdgfjhugjhkjhlksawqwrewqrwqe2121让我撒发热我虽然32";
        System.out.println(a == b);
        System.out.println(a.equals(b));
        String s3=new String("hello");
        String s4=new String("hello");
        System.out.println(s3==s4);//false
        System.out.println(s3.equals(s4));
```
字符串和字符串比较，无论是使用==，还是使用equal()比较都是一样的

#为什么HashSet能去重
MD5文件检验也是Hash的一种应用
HashSet是根据HashMap实现
HashSet之所以能去重，也是因为HashCode这个方法和equal()方法。
两个对象要完全相对必须哈希值一样。比较用equal()
比较字符串内容相等。用equal()
比较包装数值类型相等。用equal()
简单类型比较相等。用==

# 栈的一些基本问题
（1）滑动窗口
 - 1.利用一个队列来充当滑动窗口
（2）利用栈来实现队列
-  1将元素插入栈1，出栈的时候要是stack2不是空的就将stack2中的元素出栈
要是stack2中是空的就将stack1中的全部出栈，入栈到栈2
（使用两个栈 入队 - O(1)，出队 - 摊还复杂度 O(1)）<br>
摊还分析
摊还分析给出了所有操作的平均性能。摊还分析的核心在于，最坏情况下的
操作一旦发生了一次，那么在未来很长一段时间都不会再次发生，这样就会
均摊每次操作的代价。
看下面这个例子，从一个空队列开始，依次执行下面这些操作：
单次 出队 操作最坏情况下的时间复杂度为 O(n)O(n)。考虑到我们要做 nn 次
出队操作，如果我们用最坏情况下的时间复杂度来计算的话，那么所有操作
的时间复杂度为 O(n^2)O(n ^2)。
然而，在一系列的操作中，最坏情况不可能每次都发生，可能一些操作代价
很小，另一些代价很高。因此，如果用传统的最坏情况分析，那么给出的时间
复杂度是远远大于实际的复杂度的。例如，在一个动态数组里面只有一些插入
操作需要花费线性的时间，而其余的一些插入操作只需花费常量的时间。
在上面的例子中，出队 操作最多可以执行的次数跟它之前执行过 入队 操作
的次数有关。虽然一次 出队 操作代价可能很大，但是每 n 次 入队 才能产
生这么一次代价为 n 的 出队 操作。
因此所有操作的总时间复杂度为：n(所有的入队操作产生） + 2 * n(第一次出队操作产生） + n - 1(剩下的出队操作产生）， 
所以实际时间复杂度为 O(2*n)O(2∗n)。于是我们可以得到每次操作的平均时间复杂度为 O(2n/2n)O(2n/2n)=O(1)O(1)。<br>
- 2第二种（使用两个栈 入队 - O(n)， 出队 - O(1)）<br>
就是在每次入队之前，先将s1中的元素全部取出放入s2，然后入栈s1，再将s2中元素
放入s1，出栈就直接从s1中出即可。
(3)检查符号
- 1利用栈来检查符号是否对称
（4）后缀表达式
# 队列的基本问题

可以用两个栈是实现队列
（1）使用两个栈来实现队列（三种方法）
- 1首先需要两个栈，其次还要有个变量来保存栈顶元素压入自然需要将栈顶元素保存（压入 -O(1)， 弹出 -O(n)）
入队直接压入q1队列，出队是将q1队列的前面元素全部出队，进入q2，然后将最后的元素出队
然后再将q2队列中的元素压入q1
- 2 （两个栈， 压入 - O(n)O(n)， 弹出 - O(1)O(1)）
压入的时候，需要将压入对象入队列2，然后将队列1中元素全部放入2中，然后将2放入1中
出栈时候直接从队列1出。
- 3（一个栈， 压入 - O(n)O(n)， 弹出 - O(1)O(1)）
反转这一个队列里面元素的顺序
# 递归的心得
只看一个f(x)不要在意全部的，只要一个逻辑通顺，剩下就是机器自动完成
# 树的基本问题
首先应该搞明白的是树的三种遍历。
- 前序遍历：对节点的除了工作是在它的诸儿子节点被处理前进行的，也就是
说先访问根再访问左子树然后访问右子树。（根左右）
- 中序遍历：对节点的除了工作是在它的左儿子节点被处理后进行的，也就是
说先访问左节点再访问根节点然后访问右节点。（左根右）
- 后序遍历：：对节点的除了工作是在它的诸儿子节点被处理后进行的，也就
是说先访问左再访问根子树然后访问右子树。（左右根）
- 层序遍历：层序遍历需要借用队列，从根节点读入，然后出队，出队的同时
将子节点入队。
# 二叉搜索树
高效：在查找，插入，删除的时间复杂度都是O(nlogn)
查找：比较，小于当前节点则向左子树继续查找，大于则向右子树继续查找
删除：在查找到的基础上
·当左子树或者右子树为空的时候返回另一个不为空的孩子即可
·当左右子树的节点都不为空的时候，找到比自己大的最小的节点，即右子树最左的节点来替代自己的位置（或者d的前驱，即图中的53也可以代替d的位置）
·二分搜索树的中序遍历结果是按顺序排列的
·所以判断一颗二叉树是不是二分搜索树可以写出中序遍历结果，结果应该是升序的


