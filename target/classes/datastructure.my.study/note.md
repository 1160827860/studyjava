#数据结构基础
# 分清楚什么是值传递和引用传递（理解可能有问题，在基本类型方面）
值传递就是int a = 10;代表10是保存在a的地址中的。此时b = a; a = 50; 输出
的话是a = 50，b = 10;这是一种值传递对于基本类型好像都是值传递String 
也是但是对于对象，他们是引用传递引用传递就是：
例如：Node a = new Node();
这样是指向内存中某个区域
b = a;
b中存储了a中的地址
a要是内容变化就b也会改变，因为指向同一片区域
但是如果只是将a = null只是将a存储内存地址置为null，b是不会改变的,因为
只是改变了a中的存储的地址位置。

# 赋值=、浅克隆、深克隆(不是很理解)
赋值也分为三类

= ：表示将地址赋值给当前引用

浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于**非基本
类型仍然指向原有属性所指向的内存地址**，**基本类型**是**不一样的内存地址**。
extends Cloneable
继承这个接口然后调用父类的方法

深克隆：创建一个新对象，新对象的基本类型的对象类型回事不一样的。
使用序列化和反序列化，让对象接口可序列化，然后写一个对象输入输出流
将对象先读入然后输出就成了新的对象。

#在迭代器或者循环中不能对链表结构进行修改不然会报错
但是迭代器自带了remove()方法。

# java中创建泛型数组
不可以直接像创建基本数组一样创建泛型数组,
- 使用反射越过
- 或者就是使用Object

# 链表一些常见问题
ArrayList 数组队列，相当于动态数组,随机访问效率高，随机插入、删除效率
低，因为删除和插入一个，后面元素都要往后面移动，**线程不安全**。
LinkedList 双向链表，它可以当作堆栈，队列和双端队列，随机访问效率低，
但随机插入删除效率高。
Vector 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。
**Vector是线程安全的**。
Stack是栈，继承Vector，先进后出。

剑指offic<br>
（1）链表反转：
- 1：将链表里面的值保存到数组，然后利用循环倒着再添加一次，返回链表
- 2：利用一个额外容器，将第i = 0，i++个和j = size - 1 ，size--;最后一个，
即直到size/2
- 3：利用递归，DFS每次进入到链表末尾，然后从末尾到链表头。
（2）链表查找循环：<br>
- 1：利用哈希表，如果添加的时候，出现重复的情况，自然是
- 2：知道size，反转链表节点，不能到达首节点则有循环。

（3）链表去重：<br>
- 1：利用哈希表，将链表中内容保存再哈希表中，再将哈希表中内容给链表
    赋值
- 2：
- 3：

# 栈和队列自然可以用表实现

#== 和equal方法的区别
==是比较基本类型是否相同，例如int和布尔，这个也是比较在内存是位置
是否一样。
equal可以比较对象和String

字符串和字符串比较，无论是使用==，还是使用equal()比较都是一样的
#为什么HashSet能去重
MD5文件检验也是Hash的一种应用
HashSet是根据HashMap实现
HashSet之所以能去重，也是因为HashCode这个方法和equal()方法。
两个对象要完全相对必须哈希值一样。比较用equal()
比较字符串内容相等。用equal()
比较包装数值类型相等。用equal()
简单类型比较相等。用==

